#include "graph.hpp"

#include <algorithm>
#include <random>

// defining fill function, which fills an empty map with numOfNodes and randomly
// generated edges, preceded by its auxiliary functions

void removeElement(std::vector<int>::iterator const& element,
                   std::vector<int>& vec) {
  assert(element != vec.end());
  if (element + 1 != vec.end()) {
    std::rotate(element, element + 1, vec.end());
  }
  vec.pop_back();
}

std::vector<std::vector<int>>& generateRandomEdges(
    std::vector<std::vector<int>>& neighbors, int numOfNodes, int numOfEdges,
    unsigned int seed) {
  for (int i{}; i != numOfNodes; ++i) {
    // generates random unsigned ints
    std::default_random_engine eng(seed);
    // transforms the random unsigned int generated by gen into a random int
    // in the closed interval [a,b]
    std::uniform_int_distribution<> randomNeighbor(i + 1, numOfNodes - 1);
    int existingEdges{neighbors[i].size()};
    // if existingEdges >= numOfEdges, generate_n does nothing
    std::generate_n(std::back_inserter(neighbors[i]),
                    numOfEdges - existingEdges,
                    [&]() { return randomNeighbor(eng); });

    // removing possible duplicates
    std::sort(neighbors[i].begin(), neighbors[i].end());
    auto it{std::adjacent_find(neighbors[i].begin(), neighbors[i].end())};
    while (it != neighbors[i].end()) {
      removeElement(it, neighbors[i]);
      it = std::adjacent_find(neighbors[i].begin(), neighbors[i].end());
    }

    // adding i to the lists of its neighbors
    for (auto const& neighbor : neighbors[i]) {
      if (neighbor > i) {
        auto& vec{neighbors[neighbor]};
        vec.push_back(i);
      }
    }
  }

  return neighbors;
}

std::unordered_map<int, std::vector<int>>& fill(
    std::unordered_map<int, std::vector<int>>& adjList, int numOfNodes,
    int numOfEdges, unsigned int seed) {
  assert(numOfNodes > 1);
  assert(adjList.empty());

  // vector in which the nth entry represents the neighbors of the nth node
  std::vector<std::vector<int>> neighbors(numOfNodes);
  generateRandomEdges(neighbors, numOfNodes, numOfEdges, seed);
  for (int i{}; i != numOfNodes; ++i) {
    adjList[i] = neighbors[i];
  }

  return adjList;
}
